<p><a [href] = "generative"><b>Порождающие операторы</b></a> - это функции которые возвращают новый Observable, имеющий какое-то
  определенное поведение:</p>
<ul>
  <li><app-ajax></app-ajax></li>
  <li><app-defer></app-defer></li>
  <li><app-from></app-from></li>
  <li><app-of></app-of></li>
  <li><app-from-event></app-from-event></li>
  <li><app-generate></app-generate></li>
  <li><app-interval></app-interval></li>
  <li><app-timer></app-timer></li>
  <li><app-range></app-range></li>
  <li><app-throw-error></app-throw-error></li>
  <li><app-iif></app-iif></li>
</ul>

<p><a [href] = "unionGenerative"><b>Объединение порождающих операторов</b></a> - это функции, которые разделяют/объединяют/комбинируют
  результаты одного/нескольких Observable:</p>
<ul>
  <li><app-combine-latest></app-combine-latest></li>
  <li><app-fork-join></app-fork-join></li>
  <li><app-concat></app-concat></li>
  <li><app-merge></app-merge></li>
  <li><app-partition></app-partition></li>
  <li><app-race></app-race></li>
  <li><app-zip></app-zip></li>
</ul>

<p><a [href] = "pipeable"><b>Потоковые операторы</b></a> - это функции, которые могут быть использованы внутри метода .pipe():</p>
<ul>
  <li><b>На каждый результат Observable</b>
    <ul>
      <li><b>вернет результат из нового Observable для каждого значения Observable:</b>
        <ul>
          <li><app-merge-map-to></app-merge-map-to></li>
          <li><app-concat-map-to></app-concat-map-to></li>
        </ul>
      </li>
      <li><b>функция вернет новый Observable:</b>
        <ul>
          <li><app-concat-map></app-concat-map></li>
          <li><app-exhaust-map></app-exhaust-map></li>
          <li><app-switch-map></app-switch-map></li>
          <li><app-merge-scan></app-merge-scan></li>
          <li><app-audit></app-audit></li>
          <li><app-debounce></app-debounce></li>
          <li><app-throttle></app-throttle></li>
          <li><app-delay-when></app-delay-when></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b>Получить результат из Observable после получения результата из нового Observable и когда новый Observable:</b>
    <ul>
      <li><app-sample></app-sample></li>
      <li><app-skip-until></app-skip-until></li>
      <li><app-take-until></app-take-until></li>
    </ul>
  </li>


  <li><b>будет применена функция:</b></li>
  <li><b>будет применяться перехватчик:</b></li>
  <li><b>в случае ошибки:</b></li>
  <li><b>возвращает постоянное статическое значение:</b></li>
  <li><b>Буферизирует результат Observable пока:</b></li>
  <li><b>Разветвляет результат Observable на потоки:</b></li>
  <li><b>Игнорирует результат Observable:</b></li>
  <li><b>Объединяет результаты Observable и Observable высшего порядка в один Observable:</b></li>
  <li><b>Группирует пару значений в массив:</b></li>
  <li><b>Задерживает исполнение Observable на заданный период времени:</b></li>
  <li><b>Возвращает ошибку если не получен результат из Observable в течение заданного времени:</b></li>
  <li><b>Возвращает массив всех результатов Observable после того, как Observable завершится:</b></li>
  <li><b>Возвращает заданное статическое значение если после завершения Observable не был возвращен результат:</b></li>
  <li><b>Возвращает логическое значение после завершения Observable, false если было возвращено значение, а иначе true:</b></li>
  <li><b>Результат Observable возвращается с первого переданного статического значения:</b></li>

</ul>

<!--<p><a [href] = ""><i> </i></a> - .-->
<!--  <button (click)="()">()</button>-->
<!--</p>-->
