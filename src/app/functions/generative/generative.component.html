<p><a [href] = "generative"><b>Порождающие операторы</b></a> - это функции которые возвращают новый Observable, имеющий какое-то
  определенное поведение:</p>
<ul>
  <li><app-ajax></app-ajax></li>
  <li><app-defer></app-defer></li>
  <li><app-from></app-from></li>
  <li><app-of></app-of></li>
  <li><app-from-event></app-from-event></li>
  <li><app-generate></app-generate></li>
  <li><app-interval></app-interval></li>
  <li><app-timer></app-timer></li>
  <li><app-range></app-range></li>
  <li><app-throw-error></app-throw-error></li>
  <li><app-iif></app-iif></li>
</ul>

<p><a [href] = "unionGenerative"><b>Объединение порождающих операторов</b></a> - это функции, которые разделяют/объединяют/комбинируют
  результаты одного/нескольких Observable:</p>
<ul>
  <li><app-combine-latest></app-combine-latest></li>
  <li><app-fork-join></app-fork-join></li>
  <li><app-concat></app-concat></li>
  <li><app-merge></app-merge></li>
  <li><app-partition></app-partition></li>
  <li><app-race></app-race></li>
  <li><app-zip></app-zip></li>
</ul>

<p><a [href] = "pipeable"><b>Потоковые операторы</b></a> - это функции, которые могут быть использованы внутри метода .pipe():</p>
<ol>
  <li><b>На каждый результат Observable</b>
    <ul>
      <li><b>вернет результат из нового Observable для каждого значения Observable:</b>
        <ul>
          <li><app-merge-map-to></app-merge-map-to></li>
          <li><app-concat-map-to></app-concat-map-to></li>
        </ul>
      </li>

      <li><b>функция вернет новый Observable:</b>
        <ul>
          <li><app-concat-map></app-concat-map></li>
          <li><app-exhaust-map></app-exhaust-map></li>
          <li><app-switch-map></app-switch-map></li>
          <li><app-merge-scan></app-merge-scan></li>
          <li><app-audit></app-audit></li>
          <li><app-debounce></app-debounce></li>
          <li><app-throttle></app-throttle></li>
          <li><app-delay-when></app-delay-when></li>
          <li><app-expand></app-expand></li>
        </ul>
      </li>

      <li><b>будет применена функция:</b>
        <ul>
          <li><app-map></app-map></li>
          <li><app-scan></app-scan></li>
          <li><app-group-by></app-group-by></li>
          <li><app-distinct></app-distinct></li>
          <li><app-distinct-until-changed></app-distinct-until-changed></li>
          <li><app-filter></app-filter></li>
          <li><app-first></app-first></li>
          <li><app-last></app-last></li>
          <li><app-single></app-single></li>
          <li><app-take-while></app-take-while></li>
          <li><app-skip-while></app-skip-while></li>
          <li><app-every></app-every></li>
          <li><app-find></app-find></li>
          <li><app-find-index></app-find-index></li>
          <li><app-count></app-count></li>
          <li><app-max></app-max></li>
          <li><app-min></app-min></li>
          <li><app-reduce></app-reduce></li>
        </ul>
      </li>

      <li><b>будет применяться перехватчик:</b>
        <ul>
          <li><app-tap></app-tap></li>
          <li><app-time-interval></app-time-interval></li>
          <li><app-timestamp></app-timestamp></li>
        </ul>
      </li>
    </ul>
  </li>

  <li><b>Получить результат из Observable после получения результата из нового Observable и когда новый Observable:</b>
    <ul>
      <li><app-sample></app-sample></li>
      <li><app-skip-until></app-skip-until></li>
      <li><app-take-until></app-take-until></li>
    </ul>
  </li>

  <li><b>На случай ошибки в Observable:</b>
    <ul>
      <li><app-catch-error></app-catch-error></li>
      <li><app-retry-when></app-retry-when></li>
      <li><app-retry></app-retry></li>
    </ul>
  </li>

  <li><b>Буферизирует результат Observable пока:</b>
    <ul>
      <li><app-buffer></app-buffer></li>
      <li><app-buffer-when></app-buffer-when></li>
      <li><app-buffer-count></app-buffer-count></li>
      <li><app-buffer-time></app-buffer-time></li>
    </ul>
  </li>

  <li><b>Разветвляет результат Observable на потоки:</b>
    <ul>
      <li><app-window></app-window></li>
      <li><app-window-time></app-window-time></li>
      <li><app-window-count></app-window-count></li>
      <li><app-window-when></app-window-when></li>
    </ul>
  </li>

  <li><b>Игнорирует результат Observable:</b>
    <ul>
      <li><app-audit-time></app-audit-time></li>
      <li><app-debounce-time></app-debounce-time></li>
      <li><app-element-at></app-element-at></li>
      <li><app-sample-time></app-sample-time></li>
      <li><app-skip></app-skip></li>
      <li><app-skip-last></app-skip-last></li>
      <li><app-take></app-take></li>
      <li><app-take-last></app-take-last></li>
      <li><app-throttle-time></app-throttle-time></li>
      <li><app-distinct-until-key-changed></app-distinct-until-key-changed></li>
      <li><app-ignore-elements></app-ignore-elements></li>
    </ul>
  </li>

  <li><b>Объединяет результаты Observable и Observable высшего порядка в один Observable:</b>

  </li>
  <li><b>Группирует пару значений в массив:</b></li>
  <li><b>Задерживает исполнение Observable на заданный период времени:</b></li>
  <li><b>Возвращает ошибку если не получен результат из Observable в течение заданного времени:</b></li>
  <li><b>Возвращает массив всех результатов Observable после того, как Observable завершится:</b></li>
  <li><b>Возвращает заданное статическое значение если после завершения Observable не был возвращен результат:</b></li>
  <li><b>Возвращает логическое значение после завершения Observable, false если было возвращено значение, а иначе true:</b></li>
  <li><b>Результат Observable возвращается с первого переданного статического значения:</b></li>
  <li><b>возвращает постоянное статическое значение:</b></li>

</ol>

<!--<p><a [href] = ""><i> </i></a> - .-->
<!--  <button (click)="()">()</button>-->
<!--</p>-->
